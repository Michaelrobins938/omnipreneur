{"version":3,"sources":["C:\\Users\\Micha\\Favorites\\Downloads\\omnipreneur\\lib\\rate-limit\\advanced-limiter.ts"],"sourcesContent":["// @ts-nocheck\r\nimport { EventEmitter } from 'events';\r\n\r\n// Advanced rate limiting system with multiple strategies\r\nexport class AdvancedRateLimiter extends EventEmitter {\r\n  private stores: Map<string, RateLimitStore> = new Map();\r\n  private rules: Map<string, RateLimitRule[]> = new Map();\r\n  private globalLimits: Map<string, GlobalLimit> = new Map();\r\n  private whitelistedIPs: Set<string> = new Set();\r\n  private blacklistedIPs: Set<string> = new Set();\r\n  private suspiciousActivity: Map<string, SuspiciousActivity> = new Map();\r\n\r\n  constructor() {\r\n    super();\r\n    this.initializeDefaultRules();\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  // Main rate limiting function\r\n  async checkLimit(request: RateLimitRequest): Promise<RateLimitResult> {\r\n    const identifier = this.getIdentifier(request);\r\n    \r\n    // Check blacklist first\r\n    if (this.blacklistedIPs.has(request.ip)) {\r\n      return {\r\n        allowed: false,\r\n        reason: 'IP_BLACKLISTED',\r\n        resetTime: Date.now() + 3600000, // 1 hour\r\n        retryAfter: 3600\r\n      };\r\n    }\r\n    \r\n    // Check whitelist - bypass rate limits\r\n    if (this.whitelistedIPs.has(request.ip)) {\r\n      return {\r\n        allowed: true,\r\n        reason: 'WHITELISTED',\r\n        remaining: Infinity,\r\n        resetTime: Date.now() + 3600000\r\n      };\r\n    }\r\n    \r\n    // Get applicable rules\r\n    const rules = this.getRulesForRequest(request);\r\n    \r\n    // Check each rule\r\n    for (const rule of rules) {\r\n      const result = await this.checkRule(rule, identifier, request);\r\n      \r\n      if (!result.allowed) {\r\n        // Track failed attempts for suspicious activity detection\r\n        this.trackSuspiciousActivity(request.ip, rule);\r\n        \r\n        // Emit rate limit event\r\n        this.emit('rateLimit:exceeded', {\r\n          rule: rule.name,\r\n          identifier,\r\n          request,\r\n          result\r\n        });\r\n        \r\n        return result;\r\n      }\r\n    }\r\n    \r\n    // Check global limits\r\n    const globalResult = await this.checkGlobalLimits(request);\r\n    if (!globalResult.allowed) {\r\n      return globalResult;\r\n    }\r\n    \r\n    // All checks passed - record the request\r\n    await this.recordRequest(identifier, request);\r\n    \r\n    // Get remaining count for the most restrictive rule\r\n    const remaining = await this.getRemainingCount(rules, identifier);\r\n    \r\n    return {\r\n      allowed: true,\r\n      remaining,\r\n      resetTime: Date.now() + Math.min(...rules.map(r => r.window))\r\n    };\r\n  }\r\n\r\n  // Add custom rate limit rule\r\n  addRule(rule: RateLimitRule): void {\r\n    const endpoint = rule.endpoint || '*';\r\n    \r\n    if (!this.rules.has(endpoint)) {\r\n      this.rules.set(endpoint, []);\r\n    }\r\n    \r\n    this.rules.get(endpoint)!.push(rule);\r\n    \r\n    // Sort rules by priority (higher first)\r\n    this.rules.get(endpoint)!.sort((a, b) => (b.priority || 0) - (a.priority || 0));\r\n  }\r\n\r\n  // Dynamic rate limiting based on system load\r\n  async adjustLimitsBasedOnLoad(): Promise<void> {\r\n    const systemLoad = await this.getSystemLoad();\r\n    const dbLoad = await this.getDatabaseLoad();\r\n    \r\n    // Reduce limits if system is under high load\r\n    if (systemLoad > 80 || dbLoad > 80) {\r\n      this.applyLoadBasedLimits(0.5); // Reduce by 50%\r\n      this.emit('rateLimit:loadAdjustment', { systemLoad, dbLoad, factor: 0.5 });\r\n    } else if (systemLoad > 60 || dbLoad > 60) {\r\n      this.applyLoadBasedLimits(0.75); // Reduce by 25%\r\n      this.emit('rateLimit:loadAdjustment', { systemLoad, dbLoad, factor: 0.75 });\r\n    } else {\r\n      this.applyLoadBasedLimits(1.0); // Normal limits\r\n    }\r\n  }\r\n\r\n  // Sliding window rate limiting\r\n  async slidingWindowCheck(rule: RateLimitRule, identifier: string): Promise<RateLimitResult> {\r\n    const store = this.getStore(rule.name);\r\n    const now = Date.now();\r\n    const windowStart = now - rule.window;\r\n    \r\n    // Get requests in the current window\r\n    const requests = store.getRequestsInWindow(identifier, windowStart, now);\r\n    \r\n    if (requests.length >= rule.limit) {\r\n      const oldestRequest = Math.min(...requests);\r\n      const resetTime = oldestRequest + rule.window;\r\n      \r\n      return {\r\n        allowed: false,\r\n        reason: 'RATE_LIMIT_EXCEEDED',\r\n        resetTime,\r\n        retryAfter: Math.ceil((resetTime - now) / 1000),\r\n        limit: rule.limit,\r\n        remaining: 0\r\n      };\r\n    }\r\n    \r\n    return {\r\n      allowed: true,\r\n      remaining: rule.limit - requests.length - 1,\r\n      resetTime: now + rule.window\r\n    };\r\n  }\r\n\r\n  // Token bucket rate limiting\r\n  async tokenBucketCheck(rule: RateLimitRule, identifier: string): Promise<RateLimitResult> {\r\n    const store = this.getStore(rule.name);\r\n    const bucket = store.getTokenBucket(identifier) || {\r\n      tokens: rule.limit,\r\n      lastRefill: Date.now()\r\n    };\r\n    \r\n    const now = Date.now();\r\n    const timePassed = now - bucket.lastRefill;\r\n    const tokensToAdd = Math.floor(timePassed / (rule.window / rule.limit));\r\n    \r\n    // Refill tokens\r\n    bucket.tokens = Math.min(rule.limit, bucket.tokens + tokensToAdd);\r\n    bucket.lastRefill = now;\r\n    \r\n    if (bucket.tokens < 1) {\r\n      const refillTime = bucket.lastRefill + (rule.window / rule.limit);\r\n      \r\n      return {\r\n        allowed: false,\r\n        reason: 'RATE_LIMIT_EXCEEDED',\r\n        resetTime: refillTime,\r\n        retryAfter: Math.ceil((refillTime - now) / 1000),\r\n        remaining: 0\r\n      };\r\n    }\r\n    \r\n    // Consume token\r\n    bucket.tokens -= 1;\r\n    store.setTokenBucket(identifier, bucket);\r\n    \r\n    return {\r\n      allowed: true,\r\n      remaining: Math.floor(bucket.tokens),\r\n      resetTime: now + rule.window\r\n    };\r\n  }\r\n\r\n  // Fixed window rate limiting\r\n  async fixedWindowCheck(rule: RateLimitRule, identifier: string): Promise<RateLimitResult> {\r\n    const store = this.getStore(rule.name);\r\n    const now = Date.now();\r\n    const windowStart = Math.floor(now / rule.window) * rule.window;\r\n    const windowKey = `${identifier}:${windowStart}`;\r\n    \r\n    const count = store.getWindowCount(windowKey) || 0;\r\n    \r\n    if (count >= rule.limit) {\r\n      const resetTime = windowStart + rule.window;\r\n      \r\n      return {\r\n        allowed: false,\r\n        reason: 'RATE_LIMIT_EXCEEDED',\r\n        resetTime,\r\n        retryAfter: Math.ceil((resetTime - now) / 1000),\r\n        remaining: 0\r\n      };\r\n    }\r\n    \r\n    // Increment counter\r\n    store.incrementWindowCount(windowKey, rule.window);\r\n    \r\n    return {\r\n      allowed: true,\r\n      remaining: rule.limit - count - 1,\r\n      resetTime: windowStart + rule.window\r\n    };\r\n  }\r\n\r\n  // Distributed rate limiting for multi-server setups\r\n  async distributedCheck(rule: RateLimitRule, identifier: string): Promise<RateLimitResult> {\r\n    if (!rule.distributed) {\r\n      throw new Error('Rule is not configured for distributed rate limiting');\r\n    }\r\n    \r\n    // Use Redis or similar for distributed state\r\n    const distributedStore = await this.getDistributedStore();\r\n    const key = `rate_limit:${rule.name}:${identifier}`;\r\n    \r\n    const pipeline = distributedStore.pipeline();\r\n    pipeline.incr(key);\r\n    pipeline.expire(key, Math.ceil(rule.window / 1000));\r\n    \r\n    const results = await pipeline.exec();\r\n    const count = results[0][1] as number;\r\n    \r\n    if (count > rule.limit) {\r\n      const ttl = await distributedStore.ttl(key);\r\n      const resetTime = Date.now() + (ttl * 1000);\r\n      \r\n      return {\r\n        allowed: false,\r\n        reason: 'RATE_LIMIT_EXCEEDED',\r\n        resetTime,\r\n        retryAfter: ttl,\r\n        remaining: 0\r\n      };\r\n    }\r\n    \r\n    return {\r\n      allowed: true,\r\n      remaining: rule.limit - count,\r\n      resetTime: Date.now() + rule.window\r\n    };\r\n  }\r\n\r\n  // Adaptive rate limiting based on user behavior\r\n  async adaptiveCheck(rule: RateLimitRule, identifier: string, request: RateLimitRequest): Promise<RateLimitResult> {\r\n    const userProfile = await this.getUserProfile(identifier);\r\n    \r\n    // Adjust limits based on user tier\r\n    let adjustedLimit = rule.limit;\r\n    \r\n    switch (userProfile.tier) {\r\n      case 'premium':\r\n        adjustedLimit *= 2;\r\n        break;\r\n      case 'enterprise':\r\n        adjustedLimit *= 5;\r\n        break;\r\n      case 'free':\r\n        adjustedLimit *= 0.5;\r\n        break;\r\n    }\r\n    \r\n    // Adjust based on user reputation\r\n    if (userProfile.reputation > 0.8) {\r\n      adjustedLimit *= 1.5;\r\n    } else if (userProfile.reputation < 0.3) {\r\n      adjustedLimit *= 0.5;\r\n    }\r\n    \r\n    // Create adjusted rule\r\n    const adjustedRule = { ...rule, limit: Math.floor(adjustedLimit) };\r\n    \r\n    return this.slidingWindowCheck(adjustedRule, identifier);\r\n  }\r\n\r\n  // IP-based geographic rate limiting\r\n  async geographicCheck(rule: RateLimitRule, request: RateLimitRequest): Promise<RateLimitResult> {\r\n    if (!rule.geographic) return { allowed: true };\r\n    \r\n    const location = await this.getIPLocation(request.ip);\r\n    const geoRule = rule.geographic[location.country] || rule.geographic.default;\r\n    \r\n    if (!geoRule) return { allowed: true };\r\n    \r\n    const adjustedRule = { ...rule, ...geoRule };\r\n    return this.slidingWindowCheck(adjustedRule, request.ip);\r\n  }\r\n\r\n  // Burst protection\r\n  async burstProtectionCheck(rule: RateLimitRule, identifier: string): Promise<RateLimitResult> {\r\n    if (!rule.burstProtection) return { allowed: true };\r\n    \r\n    const store = this.getStore(rule.name);\r\n    const now = Date.now();\r\n    const burstWindow = rule.burstProtection.window || 1000; // 1 second default\r\n    const burstLimit = rule.burstProtection.limit || 5;\r\n    \r\n    const recentRequests = store.getRequestsInWindow(\r\n      identifier, \r\n      now - burstWindow, \r\n      now\r\n    );\r\n    \r\n    if (recentRequests.length >= burstLimit) {\r\n      return {\r\n        allowed: false,\r\n        reason: 'BURST_LIMIT_EXCEEDED',\r\n        resetTime: now + burstWindow,\r\n        retryAfter: Math.ceil(burstWindow / 1000)\r\n      };\r\n    }\r\n    \r\n    return { allowed: true };\r\n  }\r\n\r\n  // Whitelist/Blacklist management\r\n  addToWhitelist(ip: string): void {\r\n    this.whitelistedIPs.add(ip);\r\n    this.emit('whitelist:added', { ip });\r\n  }\r\n\r\n  removeFromWhitelist(ip: string): void {\r\n    this.whitelistedIPs.delete(ip);\r\n    this.emit('whitelist:removed', { ip });\r\n  }\r\n\r\n  addToBlacklist(ip: string, duration?: number): void {\r\n    this.blacklistedIPs.add(ip);\r\n    this.emit('blacklist:added', { ip, duration });\r\n    \r\n    if (duration) {\r\n      setTimeout(() => {\r\n        this.removeFromBlacklist(ip);\r\n      }, duration);\r\n    }\r\n  }\r\n\r\n  removeFromBlacklist(ip: string): void {\r\n    this.blacklistedIPs.delete(ip);\r\n    this.emit('blacklist:removed', { ip });\r\n  }\r\n\r\n  // Suspicious activity detection\r\n  private trackSuspiciousActivity(ip: string, rule: RateLimitRule): void {\r\n    const activity = this.suspiciousActivity.get(ip) || {\r\n      violations: 0,\r\n      firstViolation: Date.now(),\r\n      lastViolation: Date.now(),\r\n      rules: new Set()\r\n    };\r\n    \r\n    activity.violations++;\r\n    activity.lastViolation = Date.now();\r\n    activity.rules.add(rule.name);\r\n    \r\n    this.suspiciousActivity.set(ip, activity);\r\n    \r\n    // Auto-blacklist after threshold\r\n    if (activity.violations >= 10) {\r\n      this.addToBlacklist(ip, 3600000); // 1 hour\r\n      this.emit('security:autoBlacklist', { ip, activity });\r\n    }\r\n  }\r\n\r\n  // Get rate limit statistics\r\n  async getStatistics(timeRange: string = '1h'): Promise<RateLimitStatistics> {\r\n    const stats: RateLimitStatistics = {\r\n      totalRequests: 0,\r\n      blockedRequests: 0,\r\n      topBlockedIPs: [],\r\n      topBlockedEndpoints: [],\r\n      rules: []\r\n    };\r\n    \r\n    // Aggregate statistics from all stores\r\n    for (const [ruleName, store] of this.stores) {\r\n      const ruleStats = store.getStatistics(timeRange);\r\n      stats.totalRequests += ruleStats.totalRequests;\r\n      stats.blockedRequests += ruleStats.blockedRequests;\r\n      \r\n      stats.rules.push({\r\n        name: ruleName,\r\n        ...ruleStats\r\n      });\r\n    }\r\n    \r\n    return stats;\r\n  }\r\n\r\n  // Private helper methods\r\n  private initializeDefaultRules(): void {\r\n    // Global API rate limit\r\n    this.addRule({\r\n      name: 'global_api',\r\n      endpoint: '/api/*',\r\n      limit: 1000,\r\n      window: 3600000, // 1 hour\r\n      algorithm: 'sliding_window',\r\n      priority: 1\r\n    });\r\n    \r\n    // Authentication endpoints\r\n    this.addRule({\r\n      name: 'auth_strict',\r\n      endpoint: '/api/auth/*',\r\n      limit: 5,\r\n      window: 900000, // 15 minutes\r\n      algorithm: 'fixed_window',\r\n      priority: 10,\r\n      burstProtection: {\r\n        limit: 3,\r\n        window: 60000 // 1 minute\r\n      }\r\n    });\r\n    \r\n    // Upload endpoints\r\n    this.addRule({\r\n      name: 'upload_limit',\r\n      endpoint: '/api/upload',\r\n      limit: 50,\r\n      window: 3600000, // 1 hour\r\n      algorithm: 'token_bucket',\r\n      priority: 5\r\n    });\r\n    \r\n    // Email campaign endpoints\r\n    this.addRule({\r\n      name: 'email_campaigns',\r\n      endpoint: '/api/email-campaigns/*',\r\n      limit: 100,\r\n      window: 3600000, // 1 hour\r\n      algorithm: 'sliding_window',\r\n      priority: 3\r\n    });\r\n  }\r\n\r\n  private getIdentifier(request: RateLimitRequest): string {\r\n    // Use user ID if authenticated, otherwise IP\r\n    return request.userId || request.ip;\r\n  }\r\n\r\n  private getRulesForRequest(request: RateLimitRequest): RateLimitRule[] {\r\n    const matchingRules: RateLimitRule[] = [];\r\n    \r\n    for (const [endpoint, rules] of this.rules) {\r\n      if (this.endpointMatches(endpoint, request.endpoint)) {\r\n        matchingRules.push(...rules);\r\n      }\r\n    }\r\n    \r\n    return matchingRules.sort((a, b) => (b.priority || 0) - (a.priority || 0));\r\n  }\r\n\r\n  private endpointMatches(pattern: string, endpoint: string): boolean {\r\n    if (pattern === '*') return true;\r\n    if (pattern === endpoint) return true;\r\n    \r\n    // Simple wildcard matching\r\n    const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*') + '$');\r\n    return regex.test(endpoint);\r\n  }\r\n\r\n  private async checkRule(rule: RateLimitRule, identifier: string, request: RateLimitRequest): Promise<RateLimitResult> {\r\n    // Check burst protection first\r\n    const burstResult = await this.burstProtectionCheck(rule, identifier);\r\n    if (!burstResult.allowed) return burstResult;\r\n    \r\n    // Check geographic restrictions\r\n    const geoResult = await this.geographicCheck(rule, request);\r\n    if (!geoResult.allowed) return geoResult;\r\n    \r\n    // Apply the main algorithm\r\n    switch (rule.algorithm) {\r\n      case 'sliding_window':\r\n        return this.slidingWindowCheck(rule, identifier);\r\n      case 'token_bucket':\r\n        return this.tokenBucketCheck(rule, identifier);\r\n      case 'fixed_window':\r\n        return this.fixedWindowCheck(rule, identifier);\r\n      case 'adaptive':\r\n        return this.adaptiveCheck(rule, identifier, request);\r\n      case 'distributed':\r\n        return this.distributedCheck(rule, identifier);\r\n      default:\r\n        return this.slidingWindowCheck(rule, identifier);\r\n    }\r\n  }\r\n\r\n  private async checkGlobalLimits(request: RateLimitRequest): Promise<RateLimitResult> {\r\n    // Check global IP limit\r\n    const ipLimit = this.globalLimits.get('ip_global');\r\n    if (ipLimit) {\r\n      const store = this.getStore('global_ip');\r\n      const requests = store.getRequestsInWindow(\r\n        request.ip,\r\n        Date.now() - ipLimit.window,\r\n        Date.now()\r\n      );\r\n      \r\n      if (requests.length >= ipLimit.limit) {\r\n        return {\r\n          allowed: false,\r\n          reason: 'GLOBAL_IP_LIMIT_EXCEEDED',\r\n          resetTime: Date.now() + ipLimit.window,\r\n          retryAfter: Math.ceil(ipLimit.window / 1000)\r\n        };\r\n      }\r\n    }\r\n    \r\n    return { allowed: true };\r\n  }\r\n\r\n  private getStore(name: string): RateLimitStore {\r\n    if (!this.stores.has(name)) {\r\n      this.stores.set(name, new InMemoryRateLimitStore());\r\n    }\r\n    return this.stores.get(name)!;\r\n  }\r\n\r\n  private async recordRequest(identifier: string, request: RateLimitRequest): Promise<void> {\r\n    // Record in all applicable stores\r\n    const rules = this.getRulesForRequest(request);\r\n    \r\n    for (const rule of rules) {\r\n      const store = this.getStore(rule.name);\r\n      store.recordRequest(identifier, Date.now());\r\n    }\r\n  }\r\n\r\n  private async getRemainingCount(rules: RateLimitRule[], identifier: string): Promise<number> {\r\n    let minRemaining = Infinity;\r\n    \r\n    for (const rule of rules) {\r\n      const result = await this.checkRule(rule, identifier, {} as RateLimitRequest);\r\n      if (result.remaining !== undefined && result.remaining < minRemaining) {\r\n        minRemaining = result.remaining;\r\n      }\r\n    }\r\n    \r\n    return minRemaining === Infinity ? 0 : minRemaining;\r\n  }\r\n\r\n  private applyLoadBasedLimits(factor: number): void {\r\n    for (const [endpoint, rules] of this.rules) {\r\n      rules.forEach(rule => {\r\n        if (!rule.originalLimit) {\r\n          rule.originalLimit = rule.limit;\r\n        }\r\n        rule.limit = Math.floor(rule.originalLimit * factor);\r\n      });\r\n    }\r\n  }\r\n\r\n  private startCleanupTimer(): void {\r\n    setInterval(() => {\r\n      this.cleanup();\r\n    }, 300000); // 5 minutes\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const cleanupAge = 3600000; // 1 hour\r\n    \r\n    // Clean up old suspicious activity records\r\n    for (const [ip, activity] of this.suspiciousActivity) {\r\n      if (now - activity.lastViolation > cleanupAge) {\r\n        this.suspiciousActivity.delete(ip);\r\n      }\r\n    }\r\n    \r\n    // Clean up store data\r\n    for (const store of this.stores.values()) {\r\n      store.cleanup();\r\n    }\r\n  }\r\n\r\n  // Mock implementations for external services\r\n  private async getSystemLoad(): Promise<number> {\r\n    return Math.random() * 100;\r\n  }\r\n\r\n  private async getDatabaseLoad(): Promise<number> {\r\n    return Math.random() * 100;\r\n  }\r\n\r\n  private async getDistributedStore(): Promise<any> {\r\n    // Mock Redis client\r\n    return {\r\n      pipeline: () => ({\r\n        incr: () => {},\r\n        expire: () => {},\r\n        exec: () => Promise.resolve([[null, 1]])\r\n      }),\r\n      ttl: () => Promise.resolve(60)\r\n    };\r\n  }\r\n\r\n  private async getUserProfile(identifier: string): Promise<any> {\r\n    return {\r\n      tier: 'free',\r\n      reputation: 0.5\r\n    };\r\n  }\r\n\r\n  private async getIPLocation(ip: string): Promise<any> {\r\n    return {\r\n      country: 'US',\r\n      region: 'CA'\r\n    };\r\n  }\r\n}\r\n\r\n// In-memory rate limit store implementation\r\nclass InMemoryRateLimitStore implements RateLimitStore {\r\n  private requests: Map<string, number[]> = new Map();\r\n  private windowCounts: Map<string, { count: number; expiry: number }> = new Map();\r\n  private tokenBuckets: Map<string, TokenBucket> = new Map();\r\n\r\n  getRequestsInWindow(identifier: string, windowStart: number, windowEnd: number): number[] {\r\n    const requests = this.requests.get(identifier) || [];\r\n    return requests.filter(time => time >= windowStart && time <= windowEnd);\r\n  }\r\n\r\n  recordRequest(identifier: string, timestamp: number): void {\r\n    if (!this.requests.has(identifier)) {\r\n      this.requests.set(identifier, []);\r\n    }\r\n    this.requests.get(identifier)!.push(timestamp);\r\n  }\r\n\r\n  getWindowCount(windowKey: string): number {\r\n    const entry = this.windowCounts.get(windowKey);\r\n    if (!entry || Date.now() > entry.expiry) {\r\n      return 0;\r\n    }\r\n    return entry.count;\r\n  }\r\n\r\n  incrementWindowCount(windowKey: string, windowDuration: number): void {\r\n    const entry = this.windowCounts.get(windowKey) || { count: 0, expiry: 0 };\r\n    entry.count++;\r\n    entry.expiry = Date.now() + windowDuration;\r\n    this.windowCounts.set(windowKey, entry);\r\n  }\r\n\r\n  getTokenBucket(identifier: string): TokenBucket | null {\r\n    return this.tokenBuckets.get(identifier) || null;\r\n  }\r\n\r\n  setTokenBucket(identifier: string, bucket: TokenBucket): void {\r\n    this.tokenBuckets.set(identifier, bucket);\r\n  }\r\n\r\n  getStatistics(timeRange: string): any {\r\n    return {\r\n      totalRequests: 0,\r\n      blockedRequests: 0\r\n    };\r\n  }\r\n\r\n  cleanup(): void {\r\n    const now = Date.now();\r\n    const cleanupAge = 3600000; // 1 hour\r\n    \r\n    // Clean up old requests\r\n    for (const [identifier, requests] of this.requests) {\r\n      const filtered = requests.filter(time => now - time < cleanupAge);\r\n      if (filtered.length === 0) {\r\n        this.requests.delete(identifier);\r\n      } else {\r\n        this.requests.set(identifier, filtered);\r\n      }\r\n    }\r\n    \r\n    // Clean up expired window counts\r\n    for (const [windowKey, entry] of this.windowCounts) {\r\n      if (now > entry.expiry) {\r\n        this.windowCounts.delete(windowKey);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Type definitions\r\ninterface RateLimitRequest {\r\n  ip: string;\r\n  userId?: string;\r\n  endpoint: string;\r\n  method: string;\r\n  userAgent?: string;\r\n  headers?: Record<string, string>;\r\n}\r\n\r\ninterface RateLimitRule {\r\n  name: string;\r\n  endpoint?: string;\r\n  limit: number;\r\n  window: number; // milliseconds\r\n  algorithm: 'sliding_window' | 'token_bucket' | 'fixed_window' | 'adaptive' | 'distributed';\r\n  priority?: number;\r\n  originalLimit?: number;\r\n  distributed?: boolean;\r\n  burstProtection?: {\r\n    limit: number;\r\n    window: number;\r\n  };\r\n  geographic?: Record<string, { limit?: number; window?: number }>;\r\n}\r\n\r\ninterface RateLimitResult {\r\n  allowed: boolean;\r\n  reason?: string;\r\n  remaining?: number;\r\n  resetTime?: number;\r\n  retryAfter?: number;\r\n  limit?: number;\r\n}\r\n\r\ninterface RateLimitStore {\r\n  getRequestsInWindow(identifier: string, windowStart: number, windowEnd: number): number[];\r\n  recordRequest(identifier: string, timestamp: number): void;\r\n  getWindowCount(windowKey: string): number;\r\n  incrementWindowCount(windowKey: string, windowDuration: number): void;\r\n  getTokenBucket(identifier: string): TokenBucket | null;\r\n  setTokenBucket(identifier: string, bucket: TokenBucket): void;\r\n  getStatistics(timeRange: string): any;\r\n  cleanup(): void;\r\n}\r\n\r\ninterface TokenBucket {\r\n  tokens: number;\r\n  lastRefill: number;\r\n}\r\n\r\ninterface GlobalLimit {\r\n  limit: number;\r\n  window: number;\r\n}\r\n\r\ninterface SuspiciousActivity {\r\n  violations: number;\r\n  firstViolation: number;\r\n  lastViolation: number;\r\n  rules: Set<string>;\r\n}\r\n\r\ninterface RateLimitStatistics {\r\n  totalRequests: number;\r\n  blockedRequests: number;\r\n  topBlockedIPs: Array<{ ip: string; count: number }>;\r\n  topBlockedEndpoints: Array<{ endpoint: string; count: number }>;\r\n  rules: Array<{ name: string; [key: string]: any }>;\r\n}\r\n\r\n// Export singleton instance\r\nexport const advancedRateLimiter = new AdvancedRateLimiter();"],"names":["AdvancedRateLimiter","advancedRateLimiter","EventEmitter","stores","Map","rules","globalLimits","whitelistedIPs","Set","blacklistedIPs","suspiciousActivity","initializeDefaultRules","startCleanupTimer","checkLimit","request","identifier","getIdentifier","has","ip","allowed","reason","resetTime","Date","now","retryAfter","remaining","Infinity","getRulesForRequest","rule","result","checkRule","trackSuspiciousActivity","emit","name","globalResult","checkGlobalLimits","recordRequest","getRemainingCount","Math","min","map","r","window","addRule","endpoint","set","get","push","sort","a","b","priority","adjustLimitsBasedOnLoad","systemLoad","getSystemLoad","dbLoad","getDatabaseLoad","applyLoadBasedLimits","factor","slidingWindowCheck","store","getStore","windowStart","requests","getRequestsInWindow","length","limit","oldestRequest","ceil","tokenBucketCheck","bucket","getTokenBucket","tokens","lastRefill","timePassed","tokensToAdd","floor","refillTime","setTokenBucket","fixedWindowCheck","windowKey","count","getWindowCount","incrementWindowCount","distributedCheck","distributed","Error","distributedStore","getDistributedStore","key","pipeline","incr","expire","results","exec","ttl","adaptiveCheck","userProfile","getUserProfile","adjustedLimit","tier","reputation","adjustedRule","geographicCheck","geographic","location","getIPLocation","geoRule","country","default","burstProtectionCheck","burstProtection","burstWindow","burstLimit","recentRequests","addToWhitelist","add","removeFromWhitelist","delete","addToBlacklist","duration","setTimeout","removeFromBlacklist","activity","violations","firstViolation","lastViolation","getStatistics","timeRange","stats","totalRequests","blockedRequests","topBlockedIPs","topBlockedEndpoints","ruleName","ruleStats","algorithm","userId","matchingRules","endpointMatches","pattern","regex","RegExp","replace","test","burstResult","geoResult","ipLimit","InMemoryRateLimitStore","minRemaining","undefined","forEach","originalLimit","setInterval","cleanup","cleanupAge","values","random","Promise","resolve","region","windowEnd","filter","time","timestamp","entry","windowCounts","expiry","windowDuration","tokenBuckets","filtered"],"mappings":"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"}