{"version":3,"sources":["C:\\Users\\Micha\\Favorites\\Downloads\\omnipreneur\\lib\\upload\\file-processor.ts"],"sourcesContent":["// @ts-nocheck\r\nimport { EventEmitter } from 'events';\r\nimport { createReadStream, createWriteStream, promises as fs } from 'fs';\r\nimport { pipeline } from 'stream/promises';\r\nimport { createHash } from 'crypto';\r\nimport { extname, basename, join } from 'path';\r\nimport AdmZip from 'adm-zip';\r\n\r\n// Advanced file upload and processing system\r\nexport class FileProcessor extends EventEmitter {\r\n  private uploadDir: string;\r\n  private tempDir: string;\r\n  private maxFileSize: number;\r\n  private allowedMimeTypes: Set<string>;\r\n  private processingQueue: Map<string, ProcessingJob> = new Map();\r\n  private virusScanEnabled: boolean;\r\n\r\n  constructor(config: FileProcessorConfig = {}) {\r\n    super();\r\n    \r\n    this.uploadDir = config.uploadDir || './uploads';\r\n    this.tempDir = config.tempDir || './temp';\r\n    this.maxFileSize = config.maxFileSize || 100 * 1024 * 1024; // 100MB default\r\n    this.allowedMimeTypes = new Set(config.allowedMimeTypes || [\r\n      'image/jpeg',\r\n      'image/png',\r\n      'image/gif',\r\n      'image/webp',\r\n      'application/pdf',\r\n      'text/plain',\r\n      'text/markdown',\r\n      'application/zip',\r\n      'application/json',\r\n      'text/csv',\r\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\r\n    ]);\r\n    this.virusScanEnabled = config.virusScanEnabled || false;\r\n    \r\n    this.ensureDirectories();\r\n  }\r\n\r\n  // Upload and process files\r\n  async uploadFile(file: File, options: UploadOptions = {}): Promise<UploadResult> {\r\n    const uploadId = this.generateUploadId();\r\n    \r\n    try {\r\n      // Validate file\r\n      await this.validateFile(file, options);\r\n      \r\n      // Create processing job\r\n      const job: ProcessingJob = {\r\n        id: uploadId,\r\n        status: 'uploading',\r\n        file: {\r\n          name: file.name,\r\n          size: file.size,\r\n          type: file.type,\r\n          lastModified: file.lastModified\r\n        },\r\n        options,\r\n        startedAt: new Date().toISOString(),\r\n        progress: 0\r\n      };\r\n      \r\n      this.processingQueue.set(uploadId, job);\r\n      this.emit('upload:started', job);\r\n      \r\n      // Save file to temp location\r\n      const tempPath = await this.saveToTemp(file, uploadId);\r\n      job.tempPath = tempPath;\r\n      job.progress = 25;\r\n      this.emit('upload:progress', job);\r\n      \r\n      // Virus scan if enabled\r\n      if (this.virusScanEnabled) {\r\n        await this.virusScan(tempPath);\r\n        job.progress = 40;\r\n        this.emit('upload:progress', job);\r\n      }\r\n      \r\n      // Generate file hash\r\n      const fileHash = await this.generateFileHash(tempPath);\r\n      job.fileHash = fileHash;\r\n      job.progress = 50;\r\n      this.emit('upload:progress', job);\r\n      \r\n      // Process file based on type\r\n      const processedFiles = await this.processFile(tempPath, file, options);\r\n      job.processedFiles = processedFiles;\r\n      job.progress = 75;\r\n      this.emit('upload:progress', job);\r\n      \r\n      // Move to final location\r\n      const finalPath = await this.moveToFinal(tempPath, uploadId, file);\r\n      job.finalPath = finalPath;\r\n      job.progress = 90;\r\n      this.emit('upload:progress', job);\r\n      \r\n      // Generate metadata\r\n      const metadata = await this.generateMetadata(finalPath, file, processedFiles);\r\n      job.metadata = metadata;\r\n      job.progress = 100;\r\n      job.status = 'completed';\r\n      job.completedAt = new Date().toISOString();\r\n      \r\n      this.emit('upload:completed', job);\r\n      \r\n      return {\r\n        success: true,\r\n        uploadId,\r\n        file: {\r\n          path: finalPath,\r\n          url: this.generateFileUrl(finalPath),\r\n          hash: fileHash,\r\n          metadata\r\n        },\r\n        processed: processedFiles\r\n      };\r\n      \r\n    } catch (error) {\r\n      const job = this.processingQueue.get(uploadId);\r\n      if (job) {\r\n        job.status = 'failed';\r\n        job.error = error.message;\r\n        job.completedAt = new Date().toISOString();\r\n        this.emit('upload:failed', job);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Batch upload multiple files\r\n  async uploadMultiple(files: File[], options: UploadOptions = {}): Promise<BatchUploadResult> {\r\n    const batchId = this.generateUploadId();\r\n    const results: UploadResult[] = [];\r\n    const errors: Array<{ file: string; error: string }> = [];\r\n    \r\n    this.emit('batch:started', { batchId, fileCount: files.length });\r\n    \r\n    // Process files in parallel with concurrency limit\r\n    const concurrency = options.concurrency || 3;\r\n    const chunks = this.chunkArray(files, concurrency);\r\n    \r\n    for (const chunk of chunks) {\r\n      const chunkResults = await Promise.allSettled(\r\n        chunk.map(file => this.uploadFile(file, options))\r\n      );\r\n      \r\n      chunkResults.forEach((result, index) => {\r\n        if (result.status === 'fulfilled') {\r\n          results.push(result.value);\r\n        } else {\r\n          errors.push({\r\n            file: chunk[index].name,\r\n            error: result.reason.message\r\n          });\r\n        }\r\n      });\r\n    }\r\n    \r\n    const batchResult = {\r\n      batchId,\r\n      totalFiles: files.length,\r\n      successful: results.length,\r\n      failed: errors.length,\r\n      results,\r\n      errors\r\n    };\r\n    \r\n    this.emit('batch:completed', batchResult);\r\n    return batchResult;\r\n  }\r\n\r\n  // Create product bundle from uploaded files\r\n  async createBundle(files: Array<{ uploadId: string; metadata?: any }>, bundleOptions: BundleOptions): Promise<BundleResult> {\r\n    const bundleId = this.generateUploadId();\r\n    \r\n    try {\r\n      const zip = new AdmZip();\r\n      const bundleMetadata: any = {\r\n        id: bundleId,\r\n        name: bundleOptions.name,\r\n        description: bundleOptions.description,\r\n        createdAt: new Date().toISOString(),\r\n        files: []\r\n      };\r\n      \r\n      // Add files to bundle\r\n      for (const fileRef of files) {\r\n        const job = this.processingQueue.get(fileRef.uploadId);\r\n        if (!job || !job.finalPath) continue;\r\n        \r\n        const fileContent = await fs.readFile(job.finalPath);\r\n        const fileName = this.sanitizeFileName(job.file.name);\r\n        \r\n        // Add to ZIP\r\n        zip.addFile(fileName, fileContent);\r\n        \r\n        // Add to metadata\r\n        bundleMetadata.files.push({\r\n          name: fileName,\r\n          originalName: job.file.name,\r\n          size: job.file.size,\r\n          type: job.file.type,\r\n          hash: job.fileHash,\r\n          metadata: { ...job.metadata, ...fileRef.metadata }\r\n        });\r\n      }\r\n      \r\n      // Add bundle documentation\r\n      if (bundleOptions.includeReadme) {\r\n        const readme = this.generateBundleReadme(bundleMetadata, bundleOptions);\r\n        zip.addFile('README.md', Buffer.from(readme, 'utf8'));\r\n      }\r\n      \r\n      if (bundleOptions.includeLicense) {\r\n        const license = this.generateLicense(bundleOptions);\r\n        zip.addFile('LICENSE.txt', Buffer.from(license, 'utf8'));\r\n      }\r\n      \r\n      // Add metadata file\r\n      zip.addFile('bundle-metadata.json', Buffer.from(JSON.stringify(bundleMetadata, null, 2), 'utf8'));\r\n      \r\n      // Generate bundle file\r\n      const bundlePath = join(this.uploadDir, 'bundles', `${bundleId}.zip`);\r\n      await fs.mkdir(join(this.uploadDir, 'bundles'), { recursive: true });\r\n      \r\n      const zipBuffer = zip.toBuffer();\r\n      await fs.writeFile(bundlePath, zipBuffer);\r\n      \r\n      // Generate bundle hash\r\n      const bundleHash = await this.generateFileHash(bundlePath);\r\n      \r\n      const result: BundleResult = {\r\n        bundleId,\r\n        path: bundlePath,\r\n        url: this.generateFileUrl(bundlePath),\r\n        size: zipBuffer.length,\r\n        hash: bundleHash,\r\n        metadata: bundleMetadata,\r\n        downloadUrl: `/api/bundles/download/${bundleId}`\r\n      };\r\n      \r\n      this.emit('bundle:created', result);\r\n      return result;\r\n      \r\n    } catch (error) {\r\n      this.emit('bundle:failed', { bundleId, error: error.message });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Image processing\r\n  async processImage(imagePath: string, options: ImageProcessingOptions = {}): Promise<ProcessedImage[]> {\r\n    const processed: ProcessedImage[] = [];\r\n    const originalName = basename(imagePath, extname(imagePath));\r\n    \r\n    // Generate different sizes if requested\r\n    if (options.generateThumbnails) {\r\n      const sizes = options.thumbnailSizes || [\r\n        { width: 150, height: 150, suffix: 'thumb' },\r\n        { width: 400, height: 400, suffix: 'medium' },\r\n        { width: 800, height: 600, suffix: 'large' }\r\n      ];\r\n      \r\n      for (const size of sizes) {\r\n        const outputPath = join(\r\n          this.uploadDir, \r\n          'processed', \r\n          `${originalName}_${size.suffix}${extname(imagePath)}`\r\n        );\r\n        \r\n        await fs.mkdir(join(this.uploadDir, 'processed'), { recursive: true });\r\n        \r\n        // Mock image processing - replace with actual image library (sharp, jimp, etc.)\r\n        await fs.copyFile(imagePath, outputPath);\r\n        \r\n        processed.push({\r\n          path: outputPath,\r\n          url: this.generateFileUrl(outputPath),\r\n          width: size.width,\r\n          height: size.height,\r\n          size: (await fs.stat(outputPath)).size\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Optimize original if requested\r\n    if (options.optimize) {\r\n      const optimizedPath = join(\r\n        this.uploadDir,\r\n        'processed',\r\n        `${originalName}_optimized${extname(imagePath)}`\r\n      );\r\n      \r\n      // Mock optimization - replace with actual optimization\r\n      await fs.copyFile(imagePath, optimizedPath);\r\n      \r\n      processed.push({\r\n        path: optimizedPath,\r\n        url: this.generateFileUrl(optimizedPath),\r\n        optimized: true,\r\n        size: (await fs.stat(optimizedPath)).size\r\n      });\r\n    }\r\n    \r\n    return processed;\r\n  }\r\n\r\n  // Document processing\r\n  async processDocument(docPath: string, options: DocumentProcessingOptions = {}): Promise<ProcessedDocument> {\r\n    const result: ProcessedDocument = {\r\n      path: docPath,\r\n      url: this.generateFileUrl(docPath)\r\n    };\r\n    \r\n    // Extract text if requested\r\n    if (options.extractText) {\r\n      result.text = await this.extractTextFromDocument(docPath);\r\n    }\r\n    \r\n    // Generate preview if requested\r\n    if (options.generatePreview) {\r\n      result.preview = await this.generateDocumentPreview(docPath);\r\n    }\r\n    \r\n    // Convert to PDF if requested and not already PDF\r\n    if (options.convertToPdf && !docPath.toLowerCase().endsWith('.pdf')) {\r\n      result.pdfVersion = await this.convertToPdf(docPath);\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  // Get upload status\r\n  getUploadStatus(uploadId: string): ProcessingJob | null {\r\n    return this.processingQueue.get(uploadId) || null;\r\n  }\r\n\r\n  // Get all uploads for user\r\n  getUserUploads(userId: string, options: { page?: number; limit?: number } = {}): any {\r\n    const userUploads = Array.from(this.processingQueue.values())\r\n      .filter(job => job.options.userId === userId);\r\n    \r\n    const page = options.page || 1;\r\n    const limit = options.limit || 20;\r\n    const start = (page - 1) * limit;\r\n    const end = start + limit;\r\n    \r\n    return {\r\n      uploads: userUploads.slice(start, end),\r\n      pagination: {\r\n        page,\r\n        limit,\r\n        total: userUploads.length,\r\n        pages: Math.ceil(userUploads.length / limit)\r\n      }\r\n    };\r\n  }\r\n\r\n  // Delete upload\r\n  async deleteUpload(uploadId: string): Promise<boolean> {\r\n    const job = this.processingQueue.get(uploadId);\r\n    if (!job) return false;\r\n    \r\n    try {\r\n      // Delete files\r\n      if (job.tempPath) {\r\n        await fs.unlink(job.tempPath).catch(() => {});\r\n      }\r\n      if (job.finalPath) {\r\n        await fs.unlink(job.finalPath).catch(() => {});\r\n      }\r\n      if (job.processedFiles) {\r\n        for (const processed of job.processedFiles) {\r\n          if (processed.path) {\r\n            await fs.unlink(processed.path).catch(() => {});\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Remove from queue\r\n      this.processingQueue.delete(uploadId);\r\n      \r\n      this.emit('upload:deleted', { uploadId });\r\n      return true;\r\n      \r\n    } catch (error) {\r\n      console.error('Error deleting upload:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Private methods\r\n  private async validateFile(file: File, options: UploadOptions): Promise<void> {\r\n    // Size validation\r\n    if (file.size > this.maxFileSize) {\r\n      throw new Error(`File size ${file.size} exceeds maximum allowed size ${this.maxFileSize}`);\r\n    }\r\n    \r\n    // MIME type validation\r\n    if (!this.allowedMimeTypes.has(file.type)) {\r\n      throw new Error(`File type ${file.type} is not allowed`);\r\n    }\r\n    \r\n    // Custom validation\r\n    if (options.validator) {\r\n      const validationResult = await options.validator(file);\r\n      if (!validationResult.valid) {\r\n        throw new Error(validationResult.error || 'File validation failed');\r\n      }\r\n    }\r\n  }\r\n\r\n  private async saveToTemp(file: File, uploadId: string): Promise<string> {\r\n    const tempPath = join(this.tempDir, `${uploadId}_${file.name}`);\r\n    const buffer = await file.arrayBuffer();\r\n    await fs.writeFile(tempPath, Buffer.from(buffer));\r\n    return tempPath;\r\n  }\r\n\r\n  private async virusScan(filePath: string): Promise<void> {\r\n    // Mock virus scan - integrate with actual antivirus service\r\n    console.log(`Scanning file: ${filePath}`);\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n  }\r\n\r\n  private async generateFileHash(filePath: string): Promise<string> {\r\n    const hash = createHash('sha256');\r\n    const stream = createReadStream(filePath);\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      stream.on('data', data => hash.update(data));\r\n      stream.on('end', () => resolve(hash.digest('hex')));\r\n      stream.on('error', reject);\r\n    });\r\n  }\r\n\r\n  private async processFile(filePath: string, file: File, options: UploadOptions): Promise<any[]> {\r\n    const processed: any[] = [];\r\n    \r\n    // Process based on file type\r\n    if (file.type.startsWith('image/')) {\r\n      if (options.imageProcessing) {\r\n        const imageResults = await this.processImage(filePath, options.imageProcessing);\r\n        processed.push(...imageResults);\r\n      }\r\n    } else if (file.type === 'application/pdf' || file.type.includes('document')) {\r\n      if (options.documentProcessing) {\r\n        const docResult = await this.processDocument(filePath, options.documentProcessing);\r\n        processed.push(docResult);\r\n      }\r\n    }\r\n    \r\n    return processed;\r\n  }\r\n\r\n  private async moveToFinal(tempPath: string, uploadId: string, file: File): Promise<string> {\r\n    const finalDir = join(this.uploadDir, 'files');\r\n    await fs.mkdir(finalDir, { recursive: true });\r\n    \r\n    const finalPath = join(finalDir, `${uploadId}_${this.sanitizeFileName(file.name)}`);\r\n    await fs.rename(tempPath, finalPath);\r\n    return finalPath;\r\n  }\r\n\r\n  private async generateMetadata(filePath: string, file: File, processedFiles: any[]): Promise<any> {\r\n    const stats = await fs.stat(filePath);\r\n    \r\n    return {\r\n      originalName: file.name,\r\n      size: file.size,\r\n      type: file.type,\r\n      lastModified: new Date(file.lastModified).toISOString(),\r\n      uploadedAt: new Date().toISOString(),\r\n      processedCount: processedFiles.length,\r\n      stats: {\r\n        size: stats.size,\r\n        created: stats.birthtime.toISOString(),\r\n        modified: stats.mtime.toISOString()\r\n      }\r\n    };\r\n  }\r\n\r\n  private generateFileUrl(filePath: string): string {\r\n    const relativePath = filePath.replace(this.uploadDir, '').replace(/\\\\/g, '/');\r\n    return `${process.env.NEXT_PUBLIC_APP_URL}/api/files${relativePath}`;\r\n  }\r\n\r\n  private generateUploadId(): string {\r\n    return `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  private sanitizeFileName(fileName: string): string {\r\n    return fileName.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n  }\r\n\r\n  private chunkArray<T>(array: T[], size: number): T[][] {\r\n    const chunks: T[][] = [];\r\n    for (let i = 0; i < array.length; i += size) {\r\n      chunks.push(array.slice(i, i + size));\r\n    }\r\n    return chunks;\r\n  }\r\n\r\n  private async ensureDirectories(): Promise<void> {\r\n    const dirs = [this.uploadDir, this.tempDir, join(this.uploadDir, 'files'), join(this.uploadDir, 'processed'), join(this.uploadDir, 'bundles')];\r\n    \r\n    for (const dir of dirs) {\r\n      await fs.mkdir(dir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  private generateBundleReadme(metadata: any, options: BundleOptions): string {\r\n    return `# ${metadata.name}\r\n\r\n${metadata.description || 'Digital product bundle'}\r\n\r\n## Contents\r\n\r\n${metadata.files.map((file: any) => `- ${file.name} (${file.type})`).join('\\n')}\r\n\r\n## Created\r\n\r\n${new Date(metadata.createdAt).toLocaleDateString()}\r\n\r\n## License\r\n\r\n${options.license || 'All rights reserved'}\r\n`;\r\n  }\r\n\r\n  private generateLicense(options: BundleOptions): string {\r\n    return options.licenseText || `Digital Product License\r\n\r\nThis digital product is licensed for personal and commercial use.\r\nRedistribution is not permitted without explicit permission.\r\n\r\nCreated: ${new Date().toLocaleDateString()}\r\n`;\r\n  }\r\n\r\n  // Mock implementations for document processing\r\n  private async extractTextFromDocument(docPath: string): Promise<string> {\r\n    // Mock text extraction - integrate with actual document processing library\r\n    return 'Extracted text content...';\r\n  }\r\n\r\n  private async generateDocumentPreview(docPath: string): Promise<string> {\r\n    // Mock preview generation\r\n    return `/api/files/previews/${basename(docPath)}.png`;\r\n  }\r\n\r\n  private async convertToPdf(docPath: string): Promise<string> {\r\n    // Mock PDF conversion\r\n    const pdfPath = docPath.replace(extname(docPath), '.pdf');\r\n    await fs.copyFile(docPath, pdfPath);\r\n    return pdfPath;\r\n  }\r\n}\r\n\r\n// Type definitions\r\ninterface FileProcessorConfig {\r\n  uploadDir?: string;\r\n  tempDir?: string;\r\n  maxFileSize?: number;\r\n  allowedMimeTypes?: string[];\r\n  virusScanEnabled?: boolean;\r\n}\r\n\r\ninterface UploadOptions {\r\n  userId?: string;\r\n  validator?: (file: File) => Promise<{ valid: boolean; error?: string }>;\r\n  imageProcessing?: ImageProcessingOptions;\r\n  documentProcessing?: DocumentProcessingOptions;\r\n  concurrency?: number;\r\n}\r\n\r\ninterface ImageProcessingOptions {\r\n  generateThumbnails?: boolean;\r\n  thumbnailSizes?: Array<{ width: number; height: number; suffix: string }>;\r\n  optimize?: boolean;\r\n  format?: 'jpeg' | 'png' | 'webp';\r\n  quality?: number;\r\n}\r\n\r\ninterface DocumentProcessingOptions {\r\n  extractText?: boolean;\r\n  generatePreview?: boolean;\r\n  convertToPdf?: boolean;\r\n}\r\n\r\ninterface ProcessingJob {\r\n  id: string;\r\n  status: 'uploading' | 'processing' | 'completed' | 'failed';\r\n  file: {\r\n    name: string;\r\n    size: number;\r\n    type: string;\r\n    lastModified: number;\r\n  };\r\n  options: UploadOptions;\r\n  startedAt: string;\r\n  completedAt?: string;\r\n  progress: number;\r\n  tempPath?: string;\r\n  finalPath?: string;\r\n  fileHash?: string;\r\n  processedFiles?: any[];\r\n  metadata?: any;\r\n  error?: string;\r\n}\r\n\r\ninterface UploadResult {\r\n  success: boolean;\r\n  uploadId: string;\r\n  file: {\r\n    path: string;\r\n    url: string;\r\n    hash: string;\r\n    metadata: any;\r\n  };\r\n  processed: any[];\r\n}\r\n\r\ninterface BatchUploadResult {\r\n  batchId: string;\r\n  totalFiles: number;\r\n  successful: number;\r\n  failed: number;\r\n  results: UploadResult[];\r\n  errors: Array<{ file: string; error: string }>;\r\n}\r\n\r\ninterface BundleOptions {\r\n  name: string;\r\n  description?: string;\r\n  includeReadme?: boolean;\r\n  includeLicense?: boolean;\r\n  license?: string;\r\n  licenseText?: string;\r\n}\r\n\r\ninterface BundleResult {\r\n  bundleId: string;\r\n  path: string;\r\n  url: string;\r\n  size: number;\r\n  hash: string;\r\n  metadata: any;\r\n  downloadUrl: string;\r\n}\r\n\r\ninterface ProcessedImage {\r\n  path: string;\r\n  url: string;\r\n  width?: number;\r\n  height?: number;\r\n  size: number;\r\n  optimized?: boolean;\r\n}\r\n\r\ninterface ProcessedDocument {\r\n  path: string;\r\n  url: string;\r\n  text?: string;\r\n  preview?: string;\r\n  pdfVersion?: string;\r\n}\r\n\r\n// Export singleton instance\r\nexport const fileProcessor = new FileProcessor();"],"names":["FileProcessor","fileProcessor","EventEmitter","config","processingQueue","Map","uploadDir","tempDir","maxFileSize","allowedMimeTypes","Set","virusScanEnabled","ensureDirectories","uploadFile","file","options","uploadId","generateUploadId","validateFile","job","id","status","name","size","type","lastModified","startedAt","Date","toISOString","progress","set","emit","tempPath","saveToTemp","virusScan","fileHash","generateFileHash","processedFiles","processFile","finalPath","moveToFinal","metadata","generateMetadata","completedAt","success","path","url","generateFileUrl","hash","processed","error","get","message","uploadMultiple","files","batchId","results","errors","fileCount","length","concurrency","chunks","chunkArray","chunk","chunkResults","Promise","allSettled","map","forEach","result","index","push","value","reason","batchResult","totalFiles","successful","failed","createBundle","bundleOptions","bundleId","zip","AdmZip","bundleMetadata","description","createdAt","fileRef","fileContent","fs","readFile","fileName","sanitizeFileName","addFile","originalName","includeReadme","readme","generateBundleReadme","Buffer","from","includeLicense","license","generateLicense","JSON","stringify","bundlePath","join","mkdir","recursive","zipBuffer","toBuffer","writeFile","bundleHash","downloadUrl","processImage","imagePath","basename","extname","generateThumbnails","sizes","thumbnailSizes","width","height","suffix","outputPath","copyFile","stat","optimize","optimizedPath","optimized","processDocument","docPath","extractText","text","extractTextFromDocument","generatePreview","preview","generateDocumentPreview","convertToPdf","toLowerCase","endsWith","pdfVersion","getUploadStatus","getUserUploads","userId","userUploads","Array","values","filter","page","limit","start","end","uploads","slice","pagination","total","pages","Math","ceil","deleteUpload","unlink","catch","delete","console","Error","has","validator","validationResult","valid","buffer","arrayBuffer","filePath","log","resolve","setTimeout","createHash","stream","createReadStream","reject","on","data","update","digest","startsWith","imageProcessing","imageResults","includes","documentProcessing","docResult","finalDir","rename","stats","uploadedAt","processedCount","created","birthtime","modified","mtime","relativePath","replace","process","env","NEXT_PUBLIC_APP_URL","now","random","toString","substr","array","i","dirs","dir","toLocaleDateString","licenseText","pdfPath"],"mappings":"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"}